1) uname - утилита командной строки, выводит основную информацию об имени операционной системы и системном оборудовании.

Флаги:
-s, ( –kernel-name) – печатает имя ядра.
-n, ( –nodename) – печатает имя узла системы (имя хоста). Это имя, которое система использует при общении по сети. При использовании с опцией -n uname показывает тот же вывод, что и команда hostname.
-r, ( –kernel-release) – печатает выпуск ядра.
-v, ( –kernel-version) – печатает версию ядра.
-m, ( –machine) – печатает название аппаратного имени аппарата.
-p, ( –processor) – печатает архитектуру процессора.
-i, ( –hardware-platform) – печатает аппаратной платформы.
-o, ( –operating-system) – распечатает название операционной системы. В системах Linux это «GNU/Linux»
-a, ( –all) – при использовании опции -a uname ведет себя так же, как если бы  были заданы опции -snrvmo.
При вызове без каких-либо параметров uname печатает имя ядра, как если бы был указан параметр -s

https://andreyex.ru/linux/komanda-uname-v-linux/

//////////////////////

2) grep - утилита командной строки, в основном используется для поиска строк, соответствующих строке в тексте или содержимому файлов. Также она может находить по шаблону или регулярным выражениям.

Синтаксис: grep [опции] шаблон [имя файла...]

Флаги:
-b - показывать номер блока перед строкой;
-c - подсчитать количество вхождений шаблона;
-h - не выводить имя файла в результатах поиска внутри файлов Linux;
-i - не учитывать регистр;
- l - отобразить только имена файлов, в которых найден шаблон;
-n - показывать номер строки в файле;
-s - не показывать сообщения об ошибках;
-v - инвертировать поиск, выдавать все строки кроме тех, что содержат шаблон;
-w - искать шаблон как слово, окружённое пробелами;
-e - использовать регулярные выражения при поиске;
-An - показать вхождение и n строк до него;
-Bn - показать вхождение и n строк после него;
-Cn - показать n строк до и после вхождения;

https://losst.ru/gerp-poisk-vnutri-fajlov-v-linux

//////////////////////

3) sort утилита для вывода текстовых строк в определенном порядке. Проще говоря, для сортировки.

Синтаксис: sort опции файл

Флаги:
-b - не учитывать пробелы
-d - использовать для сортировки только буквы и цифры
-i - сортировать только по ASCII символах
-n - сортировка строк linux по числовому значению
-r - сортировать в обратном порядке
-с - проверить был ли отсортирован файл
-o - вывести результат в файл
-u - игнорировать повторяющиеся строки
-m - объединение ранее отсортированных файлов
-k - указать поле по которому нужно сортировать строки, если не задано, сортировка выполняется по всей строке.
-f - использовать в качестве разделителя полей ваш символ вместо пробела.

https://losst.ru/komanda-sort-v-linux

//////////////////////

4) uniq - утилита предназначена для поиска одинаковых строк в массивах текста. При этом с найденными совпадениями пользователь может совершать множество действий — например, удалять их из вывода либо наоборот, выводить только их. Работа команды осуществляется как с текстовыми файлами (в том числе, записями скриптов), так и с текстом, напечатанным в командной строке терминала.

Синтаксис: uniq опции файл_источник файл_для_записи

-u (--unique) — выводит исключительно те строки, у которых нет повторов.
-d (--repeated) — если какая-либо строка повторяется несколько раз, она будет выведена лишь единожды.
-D — выводит только повторяющиеся строки.
--all-repeated[=МЕТОД] — то же самое, что и -D, но при использовании этой опции между группами из одинаковых строк при выводе будет отображаться пустая строка. [=МЕТОД] может иметь одно из трех значений — none (применяется по умолчанию), separate или prepend.
--group[=МЕТОД] — выводит весь текст, при этом разделяя группы строк пустой строкой. [=МЕТОД] имеет значения separate (по умолчанию), prepend, append и both, среди которых нужно выбрать одно.
Вместе с основными опциями могут применяться дополнительные. Они нужны для более тонких настроек работы команды:

-f (--skip-fields=N) — будет проведено сравнение полей, начиная с номера, который следует после указанного вместо буквы N. Поля — это слова, хотя, называть их словами в прямом смысле слова нельзя, ведь словом команда считает любую последовательность символов, отделенную от других последовательностей пробелом либо табуляцией.
-i (--ignore-case) — при сравнении не будет иметь значение регистр, в котором напечатаны символы (строчные и заглавные буквы).
-s (--skip-chars=N) — работает по аналогии с -f, однако, игнорирует определенное количество символов, а не строк.
-c (--count) — в начале каждой строки выводит число, которое обозначает количество повторов.
-z (--zero-terminated) — вместо символа новой строки при выводе будет использован разделитель строк NULL.
-w (--check-chars=N) — указание на то, что нужно сравнивать только первые N символов в строках.

https://losst.ru/komanda-uniq-linux

//////////////////////

5) wc - утилита для обработки файлов, подсчёта количества строк, слов или байтов в тексте

Синтаксис: wc флаг файл

Команда wc может принимать ноль или более входных имен FILE (может обработать несколько файлов). Если FILE не указан или если FILE установлен -, wc будет читать стандартный ввод. Слово – это строка символов, разделенных пробелом, символом табуляции или новой строкой.

В простейшей форме, когда она используется без каких-либо опций, команда wc напечатает четыре столбца, количество строк, слов, количество байтов и имя файла для каждого указанного файла. Если файлы не указаны, (при использовании стандартного ввода) имя файла не отображается.

Флаги:
Параметр	Длинный вариант	Значение
-c	--bytes	Отобразить размер объекта в байтах
-m	--count	Показать количесто символов в объекте
-l	--lines	Вывести количество строк в объекте
-w	--words	Отобразить количество слов в объекте

https://losst.ru/komanda-wc-v-linux
https://andreyex.ru/operacionnaya-sistema-linux/komanda-wc-v-linux/

//////////////////////

6) free - Команда free без параметров возвращает результаты для  ‘total’, ‘used’, and ‘free’ объема памяти в вашей системе благодаря доступу к информации из ядра Linux. Она также отображает категории для ‘shared’, ‘buff/cache’, и ‘available’.

Чтобы избежать некоторой путаницы, давайте уточним, что означают эти термины.

Total. Эта цифра представляет всю существующую память.
Used вычисление общего значения оперативной памяти системы за вычетом выделенной свободной, разделяемой, буферной и кэш-памяти.
Free – это память, которая не используется ни для каких целей.
Shared, Buffer, и Cache идентифицируют память, используемую для нужд ядра / операционной системы. Буфер и кеш складываются вместе, а сумма указывается в разделе «buff/cache».
Available память появляется в более новых версиях free и предназначена для того, чтобы дать конечному пользователю оценку того, сколько ресурсов памяти все еще открыто для использования.
Эти уточнения важны. Неправильное присвоение значения терминам «свободная или используемая память» может привести к неправильному пониманию использования памяти вашей системой.

Это может привести к тому, что неопытный пользователь будет ложно полагать, что его система нуждается в обновлении с увеличением ОЗУ. Обратите внимание, что в предыдущих версиях не было отображения доступной памяти. Пользователи могут ошибочно полагать, что из-за высокого использования памяти их аппаратное обеспечение недостаточно мощное. Предполагается, что доступная вкладка была создана, чтобы помочь компенсировать это распространенное недоразумение.

Операционная система Linux использует кэширование для повышения производительности. В общих чертах это означает, что определенный объем памяти отводится для использования до того, как он понадобится, чтобы он мог обрабатываться быстрее. Это стандартный процесс, и вам не о чем беспокоиться, если значения не кажутся очень необычными для вашего текущего использования.

Оценка «доступной» памяти, вероятно, достаточна для того, кто просто хочет знать, как их система реагирует на определенные приложения. Если вы не можете увидеть это поле, вам может потребоваться обновить ее до последней версии. Вы можете проверить текущую версию, запустив «free -V». Наша версия 3.3.15 имеет «free» в своем выводе.

Синатксис: free [options]

Флаги:
Еще одна отличная особенность – возможность автоматизировать команду. Есть два варианта, которые помогают нам настроить этот инструмент:

Есть параметр ‘-s’, которая запускает команду free в течение заданного интервала секунд, пока пользователь не закроет программу (^ + C).
Существует также «-c», который можно использовать отдельно или в сочетании с параметром секунд. Если вы введете только «-c» и целое число (n), команда будет запускаться n раз. По умолчанию используются интервалы в одну секунду.

https://andreyex.ru/operacionnaya-sistema-linux/komanda-free-v-linux-s-primerami/

//////////////////////

7) df - утилита, которая позволяет выводить не только список подключенных устройств, но и информацию о занятом месте, а также  точку монтирования.

Синтаксис: df опции устройство
Устройство указывать необязательно, но можно указать раздел диска, о котором мы хотим посмотреть информацию.

Флаги:
-a, --all - отобразить все файловые системы, в том числе виртуальные, псевдо и недоступные;
-B - изменить размер одного блока перед выводом данных, например, можно использовать BM, чтобы вывести все данные в мегабайтах;
-h - выводить размеры в читаемом виде, в мегабайтах или гигабайтах;
-H - выводить все размеры в гигабайтах;
-i - выводить информацию об inode;
-k - выводить размеры в килобайтах;
--output - использовать специальный формат вывода, если не задано, выводит все поля. Доступны такие варианты: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent', 'size', 'used', 'avail', 'pcent', 'file' и 'target';
-P - использовать формат вывода POSIX;
--total - выводить всю информацию про использованное и доступное место;
-t, --type - выводить информацию только про указанные файловые системы;
-x - выводить информацию обо всех, кроме указанных файловых систем;

https://losst.ru/komanda-df-linux

//////////////////////

8) top - утилита, которая позволяет выводить информацию о системе, а также список процессов динамически обновляя информацию о потребляемых ими ресурсах.

Опций запуска у команды не много и использовать их активно не принято, потому что большинство действий выполняются с помощью интерактивных команд. Вот основные опции:

Флаги:
-v - вывести версию программы;
-b - режим только для вывода данных, программа не воспринимает интерактивных команд и выполняется пока не будет завершена вручную;
-c - отображать полный путь к исполняемым файлам команд;
-d - интервал обновления информации;
-H - включает вывод потоков процессов;
-i - не отображать процессы, которые не используют ресурсы процессора;
-n - количество циклов обновления данных, после которых надо закрыть программу;
-o - поле, по которому надо выполнять сортировку;
-O - вывести все доступные поля для сортировки;
-p - отслеживать только указанные по PID процессы, можно указать несколько PID;
-u - выводить только процессы, запущенные от имени указанного пользователя.

Интерактивные команды:
h - вывод справки по утилите;
q или Esc - выход из top;
A - выбор цветовой схемы;
d или s - изменить интервал обновления информации;
H - выводить потоки процессов;
k - послать сигнал завершения процессу;
W - записать текущие настройки программы в конфигурационный файл;
Y - посмотреть дополнительные сведения о процессе, открытые файлы, порты, логи и т д;
Z - изменить цветовую схему;
l - скрыть или вывести информацию о средней нагрузке на систему;
m - выключить или переключить режим отображения информации о памяти;
x - выделять жирным колонку, по которой выполняется сортировка;
y - выделять жирным процессы, которые выполняются в данный момент;
z - переключение между цветным и одноцветным режимами;
c - переключение режима вывода команды, доступен полный путь и только команда;
F - настройка полей с информацией о процессах;
o - фильтрация процессов по произвольному условию;
u - фильтрация процессов по имени пользователя;
V - отображение процессов в виде дерева;
i - переключение режима отображения процессов, которые сейчас не используют ресурсы процессора;
n - максимальное количество процессов, для отображения в программе;
L - поиск по слову;
<> - перемещение поля сортировки вправо и влево;

https://losst.ru/komanda-top-v-linux

//////////////////////

9) cut - утилита, которая используется, если нужно вырезать часть текста — при этом он может находиться в файле либо быть напечатанным через стандартный ввод. В Unix-системах эта команда удаляет секции текста, которые были обозначены при помощи байтов, символов или полей, разделенных знаками "-" и ":".

Синтаксис: cut опции путь_к_файлу
Использовать файл не обязательно. Если на месте его названия поставить прочерк - либо не указать ничего,  команда возьмет текст из стандартного ввода. При необходимости можно указывать больше файлов, чем один.

Флаги:
-b (--bytes=LIST) — номер байта, набор или диапазон байтов, подлежащих вырезанию.
-c (--characters=LIST) — символ, который следует вырезать. Также можно указывать набор либо диапазон символов.
-d (--delimiter=DELIM) — с помощью этой опции пользователь устанавливает свой разделитель вместо стандартного TAB.
-f (--fields=LIST) — перечень полей для вырезания.
-s (--only-delimited) — если была применена эта опция, cut не выводит строки, где нет разделителя.
--complement — задает байты, символы или поля, которые останутся в файле или тексте из стандартного ввода. Все остальное будет вырезано.
--output-delimiter=STRING — по умолчанию выходной разделитель соответствует входному. Эта опция позволяет задать другой выходной разделитель.
-z, --zero-terminated — вместо символа новой строки разделителем будет NULL.

https://losst.ru/komanda-cut-linux

//////////////////////

10) last - утилита командной строки, которая отображает информацию о последних сеансах входа пользователей системы.

Синтаксис: last [OPTIONS] [USER] [<TTY>...]

Флаги:
Чтобы указать количество строк, которые вы хотите напечатать в командной строке, передайте число, которому предшествует один дефис last. Например, чтобы распечатать только последние десять сеансов входа в систему, введите: last -10
-p( –present) вы можете узнать, кто вошел в систему в определенный день. Например: last -p 2020-03-10
-s( –since) - указать last отображение строк с указанного времени. Обычно комбинируется с -t( –until)
-t( –until) - указать last отображение строк до указанного времени. Обычно комбинируется с -s( –since)
Время, передаваемое параметрам -p, -s и -t может быть указано в следующих форматах:

YYYYMMDDhhmmss
YYYY-MM-DD hh:mm:ss
YYYY-MM-DD hh:mm     (seconds will be set to 00)
YYYY-MM-DD           (time will be set to 00:00:00)
hh:mm:ss             (date will be set to today)
hh:mm                (date will be set to today, seconds to 00)
now
yesterday            (time is set to 00:00:00)
today                (time is set to 00:00:00)
tomorrow             (time is set to 00:00:00)
+5min
-5days

-F - по умолчанию last не показывает секунды и год. Используйте -F, –fulltimes для просмотра полного входа и выхода времени и даты
-i( –ip) заставляет last всегда показывать IP-адрес, а -d( –dns) показывать имена хостов

https://andreyex.ru/linux/komanda-last-v-linux/

//////////////////////

11) tail - позволяет выводить заданное количество строк с конца файла, а также выводить новые строки в интерактивном режиме.

Синтаксис: tail опции файл

Флаги:
-c - выводить указанное количество байт с конца файла;
-f - обновлять информацию по мере появления новых строк в файле;
-n - выводить указанное количество строк из конца файла;
--pid - используется с опцией -f, позволяет завершить работу утилиты, когда завершится указанный процесс;
-q - не выводить имена файлов;
--retry - повторять попытки открыть файл, если он недоступен;
-v - выводить подробную информацию о файле;

https://losst.ru/komanda-tail-linux

//////////////////////

12) xargs - утилита используется, чтобы передать вывод предыдущей команды в аргументы следующей команды

Синтаксис: первая_команда | xargs опции вторая_команда аргументы

Флаги:
-0, --null - использовать в качестве разделителя нулевой символ. Обычно он находится в конце строки. По умолчанию, в качестве разделителя используется пробел, перевод строки или табуляция;
-a, --arg-file - прочитать аргументы, которые надо передать команде из файла;
-d, --delimiter - использовать нестандартный разделитель строк;
-E, -e, --eof - индикатор конца файла, все символы после вхождения этой строки игнорируются;
-l, --max-lines - количество строк, передающихся в одну команду по умолчанию все;
-n, --max-args - количество параметров, которые передаются в одну команду, по умолчанию все;
-o, --open-tty - открывать новый терминал для дочерних процессов;
-p, --interactive - спрашивать пользователя о запуске каждой следующей команды;
-r, --no-run-if-empty - если входной поток данных пустой, команда не будет выполнена;
--show-limits - посмотреть ограничения на длину параметров в командной строке;
-t, --verbose - максимально подробный вывод утилиты

https://losst.ru/komanda-xargs-linux

//////////////////////

13) awk
https://losst.ru/ispolzovanie-awk-v-linux
